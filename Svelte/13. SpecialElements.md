# Special elements
- [svelte:boundary](#svelteboundary)
- [svelte:window](#sveltewindow)
- [svelte:document](#sveltedocument)
- [svelte:body](#sveltebody)
- [svelte:head](#sveltehead)
- [svelte:element](#svelteelement)
- [svelte:options](#svelteoptions)


## svelte:boundary
⚠️ Svelte 5.3.0 或以上
boundary 允許你防止應用程序的某一部分出錯進而影響整個應用程序，並且可以從這些錯誤中恢復。
如果在渲染或更新 `<svelte:boundary>` 的子組件時發生錯誤，或在執行其中包含的任何 `$effect` 函數時發生錯誤，內容將被移除。
在渲染過程之外發生的錯誤（例如，在事件處理程序中）不會被錯誤 boundary 捕獲。

要使 boundary 發揮作用，必須提供 `failed` 和 `onerror` 中的一個或兩個。

如果提供了 `failed` snippet，它將與拋出的錯誤一起渲染，並提供一個重新創建內容的 `reset` 函數
```svelte
<svelte:boundary>
  <FlakyComponent />

  {#snippet failed(error, reset)}
    <button onclick={reset}>糟糕！再試一次</button>
  {/snippet}
</svelte:boundary>
```

如果提供了 `onerror` 函數，它將被調用並傳入相同的兩個參數 `error` 和 `reset` 。這對於使用錯誤報告服務跟蹤錯誤很有用...
```svelte
<svelte:boundary onerror={(e) => report(e)}>
  ...
</svelte:boundary>
```

...或者在 boundary 本身之外使用 `error` 和 `reset：`
```svelte
<script>
  let error = $state(null);
  let reset = $state(() => {});

  function onerror(e, r) {
    error = e;
    reset = r;
  }
</script>

<svelte:boundary {onerror}>
  <FlakyComponent />
</svelte:boundary>

{#if error}
  <button onclick={() => {
    error = null;
    reset();
  }}>
    糟糕！再試一次
  </button>
{/if}
```

## svelte:window
```svelte
<svelte:window onevent={handler} />

<svelte:window bind:prop={value} />
```
`<svelte:window>` 允許向 `window` 對象添加事件監聽器，而無需擔心在組件銷燬時移除它們，或在服務端渲染時檢查 `window` 是否存在。

`<svelte:window>` 只能出現在組件的頂層 — 它不能在區塊或元素內部。
```svelte
<script>
  function handleKeydown(event) {
    alert(`按下了 ${event.key} 鍵`);
  }
</script>

<svelte:window onkeydown={handleKeydown} />
```

還可以綁定以下屬性：
- `innerWidth`
- `innerHeight`
- `outerWidth`
- `outerHeight`
- `scrollX`
- `scrollY`
- `online` — `window.navigator.onLine` 的別名
- `devicePixelRatio`

除了 `scrollX` 和 `scrollY` 外，其他都是隻讀的。

> ⚠️ 注意，頁面不會滾動到初始值以避免可訪問性問題。只有對 `scrollX` 和 `scrollY` 綁定變量的後續更改才會導致滾動。如果你有正當理由在組件渲染時滾動，請在 `$effect` 中調用 `scrollTo()`。

## svelte:document
```svelte
<svelte:document onevent={handler} />

<svelte:document bind:prop={value} />
```

與 `<svelte:window>` 類似，此元素允許您在 `document` 上添加事件監聽器，比如 visibilitychange，這些事件不會在 window 上觸發。它還允許您在 `document` 上使用 actions。

與 `<svelte:window>` 一樣，此元素只能出現在組件的頂層，絕不能在塊或元素內部。

```svelte
<svelte:document onvisibilitychange={handleVisibilityChange} use:someAction />
```

還可以綁定以下屬性：
- `activeElement`
- `fullscreenElement`
- `pointerLockElement`
- `visibilityState`

所有屬性都是隻讀的。

## svelte:body
```svelte
<svelte:body onevent={handler} />
```

與 `<svelte:window>` 類似，這個元素允許你在 `document.body` 上添加事件監聽器，比如 `mouseenter` 和 `mouseleave`，這些事件在 `window` 上是不會觸發的。它還允許你在 `<body>` 元素上使用 actions。

與 `<svelte:window>` 一樣，這個元素只能出現在組件的頂層，且絕不能在區塊或元素內部。

```svelte
<svelte:body onmouseenter={handleMouseenter} onmouseleave={handleMouseleave} use:someAction />
```

## svelte:head
這個元素可以將元素插入到 `document.head` 中。在服務端渲染期間，`head` 內容與主要的 `body` 內容是分開暴露（exposed）的。

```svelte
<svelte:head>
  <title>Hello world!</title>
  <meta name="description" content="This is where the description goes for SEO" />
</svelte:head>
```

與 `<svelte:window>` 一樣，這個元素只能出現在組件的頂層，且絕不能在區塊或元素內部。

## svelte:element
這個和前一個 `<svelte:component>` 很像，只是 `component` 是針對自訂的組件(也就是大小開頭的元素)，而 `element` 只針對內建的元素。

如果 this 是空值（nullish value），該元素及其子元素都不會被渲染。

如果 this 是空元素（例如 br）的名稱，並且 `<svelte:element>` 包含子元素，在開發模式下將會拋出運行時錯誤：

```svelte
	<script lang="ts">
    const elements = ['h1', 'h2', 'h3'];
 
    let selectedElement = elements[0];
</script>
 
<h1>App</h1>
 
<select bind:value={selectedElement}>
    {#each elements as element (element)}
        <option value={element}>{element}</option>
    {/each}
</select>
 
<hr />
 
<svelte:element this={selectedElement}>{selectedElement}</svelte:element>
```

```svelte
<!-- ❌ 動態指定元素的時候不能夠 bind:value -->
<svelte:element this={'input'} bind:value={text} />

<!-- ✅ 這樣可以，因為他不是動態指定 -->
<svelte:element this="input" bind:value={text} />
<!-- 這樣不如 -->
<input type="text" bind:value={text} />
```

## svelte:options
修改一些編譯器的設定(以組件為範圍)
- `runes={true}` — 強制組件進入 Runes 模式
- `runes={false}` — 強制組件進入 Legacy 模式 
- `namespace="..."` — 該組件將使用的命名空間，可以是 "html"（預設）、"svg" 或 "mathml"
- `customElement={...}` — 將此組件編譯為自定義元素時使用的選項。如果傳入字符串，則將其用作 tag 選項
- `css="injected"` — 該組件將內聯注入其樣式：在服務端渲染期間，它會作為 `<style>` 標籤注入到 `head` 中，在客户端渲染期間，它通過 JavaScript 加載
