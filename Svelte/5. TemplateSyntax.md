# Template syntax
- [{#if ...}](#if-)
- [{#each ...}](#each-)
- [{#key ...}](#key-)
- [{#await ...}](#await-)

## {#if ...}
```svelte
{#if answer === 42}
	<p>what was the question?</p>
{/if}

{#if temperature > 100}
	<p>too hot!</p>
{:else if 80 > temperature}
	<p>too cold!</p>
{:else}
	<p>just right!</p>
{/if}
```


## {#each ...}
```svelte
<h1>Shopping list</h1>
<ul>
	{#each items as item}
		<li>{item.name} x {item.qty}</li>
	{/each}
</ul>

<!-- each 還可以指定一個 index -->
<ul>
	{#each items as item, i}
		<li>{i + 1}：{item.name} x {item.qty}</li>
	{/each}
</ul>
```

### 帶有 key 的 each
如果提供了一個 key 表達式（必須能唯一標識每個列表項 ex:id），當數據發生變化時，Svelte 將使用它對列表進行差異比較，而不是在末尾添加或刪除條目。key 可以是任何對象，但建議使用字符串和數字，因為它們允許在對象本身發生變化時保持標識繼續存在。
```svelte
{#each items as item (item.id)}
	<li>{item.name} x {item.qty}</li>
{/each}

<!-- 或帶有索引值 -->
{#each items as item, i (item.id)}
	<li>{i + 1}: {item.name} x {item.qty}</li>
{/each}
```
### 可以在 each 中使用解構和剩餘模式。
```svelte
{#each items as { id, name, qty }, i (id)}
	<li>{i + 1}: {name} x {qty}</li>
{/each}

{#each objects as { id, ...rest }}
  <li>
    <span>{id}</span>
    <MyComponent values={rest} />
  </li>
{/each}

{#each items as [id, ...rest]}
	<li>
    <span>{id}</span>
    <MyComponent values={rest} />
  </li>
{/each}
```

### 不帶 item 的 each
```svelte
<div>
	{#each { length: 8 }, index}
    <span>{index}</span>
	{/each}
</div>
```

### 使用 {:else}
each 還可以有一個 `{:else}` 子句，當 list 為空時會渲染該子句。
```svelte
{#each todos as todo}
	<p>{todo.text}</p>
{:else}
	<p>今天沒有任務！</p>
{/each}
```


## {#key ...}
當 value 發生變化時，Key 塊會銷燬並重新創建其內容。當用在組件時，這將導致組件被重新實例化和重新初始化：
```svelte
{#key value}
	<Component />
{/key}
```

如果想要在值發生變化時播放過渡效果，也可以使用：
```svelte
{#key value}
	<div transition:fade>{value}</div>
{/key}
```


## {#await ...}
```svelte
{#await expression}...{:then name}...{:catch name}...{/await}

<!-- 不需要在 promise 被拒絕時渲染任何內容（或不可能出現錯誤），可以省略 catch 塊。 -->
{#await expression}...{:then name}...{/await}

<!-- 不關心等待狀態，你也可以省略初始塊。 -->
{#await expression then name}...{/await}

<!-- 只想顯示錯誤狀態，你可以省略 then 塊。 -->
{#await expression catch name}...{/await}
```

```svelte
{#await promise}
	<!-- promise 正在等待中 -->
	<p>waiting for the promise to resolve...</p>
{:then value}
	<!-- promise 已完成或不是一個 Promise -->
	<p>The value is {value}</p>
{:catch error}
	<!-- promise 被拒絕 -->
	<p>Something went wrong: {error.message}</p>
{/await}
```

在服務端渲染期間，只會渲染等待中分支。
```svelte
{#await promise}
  <!-- ✅ SSR 時只渲染這個分支 -->
  <div>加載中...</div>
{:then data}
  <!-- ❌ SSR 時不渲染，因為服務器無法等待 Promise 完成 -->
  <div>{data}</div>
{/await}
```

如果提供的表達式不是一個 Promise，則只會渲染 :then 分支，包括在服務端渲染期間。
```svelte
{#await "立即值"}
  <!-- ❌ 永遠不渲染，因為不是 Promise -->
  <div>加載中...</div>
{:then value}
  <!-- ✅ 立即渲染這個分支 -->
  <div>{value}</div>
{/await}
```

可以将 `#await` 和 `import(...)` 一起使用实现组件懒加载：
```svelte
{#await import('./Component.svelte') then { default: Component }}
	<Component />
{/await}

```
