# Runes
1. [$state](#state)
	- [$state](#state-1)
	- [$state.raw](#stateraw)
2. [$derived](#derived)
	- [$derived](#derived-1)
	- [$derived.by](#derivedby)
3. [#effect](#effect)
  - [#effect](#effect-1)
	- [#effect.pre](#effectpre)
	- [untrack](#untrack)

## $state
### `$state`

```svelte
<script>
	let count = $state(0);

  let todoList = $state([
    { done: false, text: "todo A" }
  ])

  todoList.push({ done: false, text: "todo B" });

  todoList[0].done = !todoList[0].done
</script>

<button onclick={() => count++}>
	點擊次數: {count}
</button>
```

### `$state.raw`
在不希望對象和數組具有深度響應性的情況下，可以使用 $state.raw。
```svelte
<script>
let person = $state.raw({
	name: 'Heraclitus',
	age: 49
});

// not work
person.age += 1; 

// work
person = {
	name: 'Heraclitus',
	age: 50
};
</script>
```

## $derived
### `$derived`
```svelte
<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
	{doubled}
</button>

<p>{count} 的兩倍是 {doubled}</p>
```

### `$derived.by`
需要複雜演算時使用
```svelte
<script>
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() => {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
	{numbers.join(' + ')} = {total}
</button>
```

## $effect
### `$effect`
```svelte
<script>
	let size = $state(50);
	let color = $state('#ff3e00');

	let canvas;

	$effect(() => {
		const context = canvas.getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);

		// case 1
		// 只要 `color` 或 `size` 發生變化，這段代碼就會重新執行
		context.fillStyle = color;
		context.fillRect(0, 0, size, size);

    // case 2 
		// 當 `color` 發生變化時，這段代碼會重新執行，但當 `size` 發生變化時卻不會重新執行
		context.fillStyle = color;
		setTimeout(() => {
			context.fillRect(0, 0, size, size);
		}, 0);
	});
</script>

<canvas bind:this={canvas} width="100" height="100"></canvas>
```
重新運行是批量處理的（即在同一時刻更改 color 和 size 不會導致兩次單獨的運行），並在所有 DOM 更新完成後發生。

`$effect` 會自動獲取在其函數體內 同步 讀取的任何響應值（$state、$derived、$props），並將它們註冊為依賴關係。當這些依賴關係發生變化時，$effect 會安排重新運行。
在 Promise?async/await 之後或在 setTimeout 內部等情況下讀取的值將不會被追蹤。
在這裏，當 color 變化時，canvas 會重新繪製，但當 size 變化時將不會變化。

--

`$effect` retrun 一個函數，該函數將在 effect 重新運行之前立即運行，並在它被銷燬之前運行
```svelte
<script>
	let count = $state(0);
	let milliseconds = $state(1000);

	$effect(() => {
		// 每當 `milliseconds` 變化時，這段代碼都會被重新創建
		const interval = setInterval(() => {
			count += 1;
		}, milliseconds);

		return () => {
			// a) effect 重新運行之前立即被調用
			// b) 當組件被銷燬時被調用
			clearInterval(interval);
		};
	});
</script>

<h1>{count}</h1>

<button onclick={() => (milliseconds *= 2)}>慢一點</button>
<button onclick={() => (milliseconds /= 2)}>快一點</button>
```
--

`$effect` 只會根據實際「讀取（read）」的變數建立依賴（前次執行 effect 時讀取的值），而不是整個作用域裡的所有變數。
如果 a 為真，則 if (a || b) 成立， a 和 b 雖然都出現在程式裡，但只有 a 被真正「讀取」了（因為 a || b 是短路求值）
b 沒有「明確使用」，所以只有 a 被建立成「依賴」，因此對 b 更改不會導致該 `$effect` 重新運行:
```svelte
<script>
	let a = $state(true);
	let b = $state(false);

	$effect(() => {
		console.log('運行中');
	
		if (a || b) {
			console.log('在 if 塊內');
		}
	});

	let condition = $state(true);
	let c = $state(1);
	let d = $state(1);

	$effect(() => {
		console.log('c,d 運行中');

		if (condition) {
			console.log('c', c)
		} else {
			console.log('d', d)
		} 
	});

	// setTimeout(() => {
	// 	console.log('d++');
	// 	d++;
	// }, 1000);
	setTimeout(() => {
		console.log('condition changed')
		condition = !condition;
		setTimeout(() => {
			console.log('d++')
			d++;
		}, 1000);
	}, 1000);
</script>
```

### `$effect.pre`
如果需要在 DOM 更新之前執行代码（畫面更新前生效）。可以使用 `$effect.pre`。
ex：寫入資料前處理、同步 state、避免UI閃爍等。

### `$effect.tracking`
```svelte
<script>
  let count = $state(0);
  let logs = $state([]);
  
  function addLog(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const context = $effect.tracking() ? 'reactive' : 'manual';
    
    logs.push({
      message,
      type,
      context,
      timestamp
    });
  }
  
  // 這會在響應式上下文中執行
  $effect(() => {
    addLog(`Count changed to ${count}`, 'reactive');
  });
  
  function handleManualLog() {
    // 這會在非響應式上下文中執行
    addLog('Manual button clicked', 'manual');
  }
</script>

<button onclick={() => count++}>增加 Count</button>
<button onclick={handleManualLog}>手動日誌</button>

{#each logs as log}
  <div class="log-{log.context}">
    [{log.timestamp}] {log.context}: {log.message}
  </div>
{/each}
```

### `$effect.root`
創建一個獨立的 effect 根作用域。它主要用於在組件生命週期之外管理副作用，或者創建可以手動控制的 effect 群組。
核心概念
`$effect.root` 會返回一個清理函數，當你調用這個函數時，會銷毀該根作用域下的所有 effects。這在需要精確控制副作用生命週期的場景中非常有用。
```ts
const cleanup = $effect.root(() => {
  // 在這裡定義你的 effects
  $effect(() => {
    // 副作用邏輯
  });
  
  // 可以定義多個 effects
  $effect(() => {
    // 另一個副作用
  });
});

// 當需要清理時，調用返回的函數
cleanup();
```

### `untrack`
如果必須在 `$effect` 內更新 `$state`，並且由於讀取和寫入相同的 `$state` 而陷入無限循環，請使用 untrack。
在 `$derived` 或 `$effect` 內部使用時，fn 內部讀取的任何狀態都不會被視為依賴項。
```ts
let data = $state({timestamp: 0})
let time = $state(500)

$effect(() => {
	// 當 `data` 改變時執行，但當 `time` 改變時不會執行
		data.timestamp = untrack(() => time)
});
```