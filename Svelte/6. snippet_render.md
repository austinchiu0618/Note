# Template syntax
- [{#snippet ...}](#snippet-)
   - [Passing snippets to components](#passing-snippets-to-components)
   - [Typing snippets](#typing-snippets)
   - [Exporting snippets](#exporting-snippets)
- [{@render}](#snippet-)

## {#snippet ...}
snippet 和 render tags 在組件內部創建後，可複用的一種方法

```svelte
{#snippet figure(image)}
  <figure>
    <img src={image.src} alt={image.caption} width={image.width} height{image.height} />
    <figcaption>{image.caption}</figcaption>
  </figure>
{/snippet}

{#each images as image}
    {#if image.href}
        <a href={image.href}>
                {@render figure(image)}
        </a>
    {:else}
        {@render figure(image)}
    {/if}
{/each}
```

### Snippet scope
snippet 可以在組件的任何地方聲明。它們可以引用在自身之外聲明的值，例如在 `<script>` 標籤或 `{#each ...}` 塊中
```svelte
<script>
	let { message = `it's great to see you!` } = $props();
</script>

{#snippet hello(name)}
	<p>hello {name}! {message}!</p>
{/snippet}

{@render hello('alice')}
{@render hello('bob')}
```

⚠️ 注意 snippet 作用域
```svelte
<div>
	{#snippet x()}
		{#snippet y()}...{/snippet}

		<!-- this is fine -->
		{@render y()}
	{/snippet}

	<!-- this will error, as `y` is not in scope -->
	{@render y()}
</div>

<!-- this will also error, as `x` is not in scope -->
{@render x()}
```

snippet 可以引用自身和其他 snippet
```svelte
{#snippet blastoff()}
	<span>🚀</span>
{/snippet}

{#snippet countdown(n)}
	{#if n > 0}
		<span>{n}...</span>
    <!-- 引用自身 -->
		{@render countdown(n - 1)} 
	{:else}
    <!-- 引用其他 snippet -->
		{@render blastoff()}
	{/if}
{/snippet}

{@render countdown(10)}
```

### Passing snippets to components
在模板中，snippet 和其他值一樣。它們可以作為 props 傳遞給組件

```svelte
<script>
	import Table from './Table.svelte';

	const fruits = [
		{ name: 'apples', qty: 5, price: 2 },
		{ name: 'bananas', qty: 10, price: 1 },
		{ name: 'cherries', qty: 20, price: 0.5 }
	];
</script>

{#snippet header()}
	<th>fruit</th>
	<th>qty</th>
	<th>price</th>
	<th>total</th>
{/snippet}

{#snippet row(d)}
	<td>{d.name}</td>
	<td>{d.qty}</td>
	<td>{d.price}</td>
	<td>{d.qty * d.price}</td>
{/snippet}

<Table data={fruits} {header} {row} />
```

組件標籤內的任何不是 snippet 聲明的內容都將隱含成為 children snippet的一部分。
`App.svelte`
```svelte
<MyButton>click me</MyButton>
```

`MyButton.svelte`
```svelte
<script>
  let { children } = $props();
</script>

<!-- 結果將是 <button>click me</button> -->
<button>{@render children()}</button>
```

可以將代碼片段 props 聲明為可選的。
```svelte
<script>
  let { children } = $props();
</script>

{@render children?.()}

<!-- 或者使用 #if 來渲染其他內容 -->
{#if children}
  {@render children()}
{:else}
  <!-- 其他內容 -->
{/if}
```

### Typing snippets
```svelte
<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		data: any[];
		children: Snippet;
		row: Snippet<[any]>;
	}

	let { data, children, row }: Props = $props();
</script>
```
如果嘗試在沒有提供 `data` prop 和 `row` 代碼片段的情況下使用該組件，則會出現紅色波浪線。請注意，提供給 `Snippet` 的類型參數是一個元組，因為代碼片段可以有多個參數。
我們可以通過聲明泛型來進一步收窄類型，以便 `data` 和 `row` 引用相同的類型：

```svelte
<script lang="ts" generics="T">
  import type { Snippet } from 'svelte';

  let {
    data,
    children,
    row
  }: {
    data: T[];
    children: Snippet;
    row: Snippet<[T]>;
  } = $props();
</script>
```

### Exporting snippets
⚠️ Svelte 5.5.0 以上

`snippets.svelte`
```svelte
<script module>
  export { add };
</script>

{#snippet add(a, b)}
  {a} + {b} = {a + b}
{/snippet}
```

`App.svelte`
```svelte
<script>
	import { add } from './snippets.svelte';
</script>

{@render add(1, 2)}
```

> 在 Svelte 4 中，可以使用 插槽 將內容傳遞給組件。代碼片段更強大、更靈活，因此在 Svelte 5 中插槽已被棄用。


## {@render ...}
要渲染一個 snippet，請使用 {@render ...}。

```svelte
{#snippet sum(a, b)}
	<p>{a} + {b} = {a + b}</p>
{/snippet}

{@render sum(1, 2)}
{@render sum(3, 4)}
{@render sum(5, 6)}
```

可以是任意的 JavaScript 表達式。
```svelte
{@render (cool ? coolSnippet : lameSnippet)()}
```