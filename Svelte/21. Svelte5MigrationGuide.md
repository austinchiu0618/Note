# Svelte 5 migration guide

## Reactivity syntax changes

### let -> $state
在 Svelte 4 中，組件頂層的 let 聲明是隱式響應式的。

在 Svelte 5 中，事情變得更明確：當使用 $state 符文創建變量時，該變量是響應式的。

```js
// Svelte 4
let count = 0;

// Svelte 5
let count = $state(0);
```

```js
// Svelte 4
$: doubled = count * 2;

// Svelte 5
let doubled = $derived(count * 2);
```

```js
// Svelte 4
$: {
  console.log(count);
}

// Svelte 5
$effect(() => {
  console.log(count);
});
```

### export let -> $props
在 Svelte 4 中，組件的屬性是通過 `export let` 聲明的。每個屬性都是一個聲明。

在 Svelte 5 中，所有屬性都是通過 `$props` 符文聲明的，通過解構：

```js
  // Svelte 4
	export let optional = 'unset';
	export let required;

  // Svelte 5
	let { optional = 'unset', required } = $props();
```

## Event changes
在 Svelte 4 中，我們使用 on: 指令將事件監聽器附加到元素上。

在 Svelte 5 中，去掉冒號：
```svelte
  <!-- Svelte 4 -->
  <button on:click={() => count++}>
	  點擊次數：{count}
  </button>

  <!-- Svelte 5 -->
  <button onclick={() => count++}>
  	點擊次數：{count}
  </button>
```

### Component events
在 Svelte 4 中，組件可以使用 createEventDispatcher 創建一個調度器來發出事件。

該函數在 Svelte 5 中已棄用。相反，組件應接受 回調屬性 —— 這意味着您可以將函數作為屬性傳遞給這些組件：

`App.svelte`
```svelte
<script>
const onEvent = () => {}
</script>
<!-- Svelte 4 -->
<MyComponent on:customEvent = {onEvent}/>

<!-- Svelte 5 -->
<MyComponent customEvent = {onEvent}/>
```

`MyComponent.svelte`
```svelte
<script>
  // Svelte 4
  import { createEventDispatcher } from 'svelte';
  const dispatch = createEventDispatcher();

  // Svelte 5
  const { customEvent } = $props()
</script>

<!-- Svelte4 -->
<button on:click={dispatch('customEvent')}>Click</button>

<!-- Svelte 5 -->
<button onclick={customEvent}>Click</button>
```

### Event modifiers
在 Svelte 4 中，您可以向事件處理程序添加事件修飾符：
```svelte
<button on:click|once|preventDefault={handler}>...</button>
```

在 Svelte 5 , 事件處理程序只是函數，需要根據需要創建自己的封裝：
```svelte
<script>
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
</script>

<button onclick={once(preventDefault(handler))}>...</button>
```

對於 capture，我們將修飾符添加到事件名稱中：

```svelte
<button onclickcapture={...}>...</button>
```

### Multiple event handlers
```svelte
<!-- Svelte 4 -->
<button on:click={one} on:click={two}>...</button>

<!-- Svelte 5 -->
<button onclick={(e) => {
		one(e);
		two(e);
}}>
	...
</button>
```


## Snippets instead of slots
在 Svelte 4 中，傳遞 UI 給子組件的最簡單方法是使用一個 `<slot />`。

在 Svelte 5 中，改為使用 `children` 屬性，然後通過 `{@render children()}` 顯示：

想要多個 UI 佔位符，必須使用命名插槽。在 Svelte 5 中，改為使用 props，隨意命名它們，並 `{@render ...}` 它們：

```svelte
<script>
	let { header, main, footer } = $props();
</script>

<header>
	<slot name="header" />
	{@render header()}
</header>

<main>
	<slot name="main" />
	{@render main()}
</main>

<footer>
	<slot name="footer" />
	{@render footer()}
</footer>
```

### Passing data back up
`App.svelte`
```svelte
<script lang="ts">
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
  <!-- Svelte 4 -->
	<span slot="empty">No items yet</span>

  <!-- Svelte 5 -->
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
```

`List.svelte`
```svelte
<script lang="ts">
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
        <!-- Svelte 4 -->
        <slot item={entry} /> 
        <!-- Svelte 5 -->
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
  <!-- Svelte 4 -->
	<slot name="empty" />
  <!-- Svelte 5 -->
	{@render empty?.()}
{/if}
```

## Migration script
可以使用 `npx sv migrate svelte-5` 升級項目

(...待補)

## Components are no longer classes
在 Svelte 3 和 4 中，組件是類。在 Svelte 5 中，它們是函數，應該以不同方式實例化。如果您需要手動實例化組件，應該使用 `mount` 或 `hydrate`（從 svelte 導入）。如果在使用 SvelteKit 時看到此錯誤，請先嚐試更新到最新版本的 SvelteKit，該版本添加了對 Svelte 5 的支持。如果您在沒有 SvelteKit 的情況下使用 Svelte，您可能會有一個 main.js 文件（或類似的文件），需要進行調整：

### Server API changes
同組件在服務端渲染編譯時，不再具有 render 方法。

改為 svelte/server 的 render：
```js
import App from './App.svelte';
// Svelte 5
import { render } from 'svelte/server'; 
const { html, head } = render(App, { props: { message: 'hello' }});

// Svelte 4
const { html, head } = App.render({ props: { message: 'hello' }});
```
在 Svelte 4 中，將組件渲染為字符串也會返回所有組件的 CSS。在 Svelte 5 中，預設情況下不再這樣，因為大多數情況下使用工具鏈以其他方式處理它（例如 SvelteKit）。如果您需要從 `render` 返回 CSS，可以將 `css` 編譯器選項設置為 `'injected'`，它將在 `head` 中添加 `<style>` 元素。

## `<svelte:component>` is no longer necessary
```svelte
<script>
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
</script>

<select bind:value={Thing}>
	<option value={A}>A</option>
	<option value={B}>B</option>
</select>

<!-- these are equivalent -->
<!-- Svelte 5 -->
<Thing />

<!-- Svelte 4 -->
<svelte:component this={Thing} />
```

在 Svelte 4 中，`<foo.bar>` 將創建一個標籤名為 "foo.bar" 的元素。

在 Svelte 5 中，foo.bar 被視為組件。這在 each 塊中特別有用：

```svelte
{#each items as item}
	<item.component {...item.props} />
{/each}
```

## Whitespace handling changed
(...待補)

## Modern browser required
Svelte 5 需要現代瀏覽器（換句話説，不支持 Internet Explorer），原因如下：

- 它使用 Proxies
- 具有 `clientWidth`/`clientHeight`/`offsetWidth`/`offsetHeight` 綁定的元素使用 `ResizeObserver`，而不是複雜的 `<iframe>` 技巧
- `<input type="range" bind:value={...} />` 僅使用 `input` 事件監聽器，而不是同時監聽 `change` 事件作為後備方案

legacy 編譯器選項（該選項生成體積較大但兼容 IE 的代碼）不再存在。

## Changes to compiler options
(...待補)


## The children prop is reserved
(...待補)


## Breaking changes in runes mode
### Bindings to component exports are not allowed
Runes 模式下，組件的導出不能直接綁定。例如，組件 A 中有 `export const foo = ...`，然後執行 `<A bind:foo />`，將導致錯誤。
使用 bind:this 代替——`<A bind:this={a} />`——並通過 `a.foo` 訪問導出。此更改使事情更容易理解，因為它強制了屬性和導出之間的清晰分離。


(...待補)


## Other breaking changes
(...待補)