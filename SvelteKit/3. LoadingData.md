# Loading data

在渲染一個 `+page.svelte` 組件(及其包含的 `+layout.svelte` 組件)之前，我們通常需要獲取一些數據。這是通過定義 `load` 函數來實現的。

## Page data
`src/routes/blog/[slug]/+page.svelte`
```svelte
<script>
	/** @type {{ data: import('./$types').PageData }} */
	let { data } = $props();

    // Svelte 4
    export let data
</script>

<h1>{data.title}</h1>
<div>{@html data.content}</div>
```
> 在 Svelte 4 中，需要使用 `export let data` 代替

`src/routes/blog/[slug]/+page`
```js
import { error } from '@sveltejs/kit';

// import type { PageLoad } from './$types';
/** @type {import('./$types').PageLoad} */
export function load({ params }) {
	if (params.slug === 'hello-world') {
		return {
			title: 'Hello world!',
			content: 'Welcome to our blog. Lorem ipsum dolor sit amet...'
		};
	}

	error(404, 'Not found');
}
```

`+page.js` 文件中的 `load` 函數在服務端和瀏覽器上都會運行(除非與 `export const ssr = false` 結合使用，在這種情況下它將僅在瀏覽器中運行)。如果您的 `load` 函數應該始終在服務端上運行(例如，因為它使用了私有環境變量或訪問數據庫)，那麼它應該放在 `+page.server.js` 中。

一個更貼合實際的 blog 文章 `load` 函數示例，它只在服務端上運行並從數據庫中獲取數據。可能如下所示:

` src/routes/blog/[slug]/+page.server.js`
```js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
	export function getPost(slug: string): Promise<{ title: string, content: string }>
}

// @filename: index.js
// ---cut---
import * as db from '$lib/server/database';

/** @type {import('./$types').PageServerLoad} */
export async function load({ params }) {
	return {
		post: await db.getPost(params.slug)
	};
}
```

注意類型從 `PageLoad` 變為 `PageServerLoad`，因為服務端 `load` 函數可以訪問額外的參數。

要了解何時使用 `+page.js` 和何時使用 `+page.server.js` , 文檔：[高級路由 - Universal 與 server。]()

## Layout data
`+layout.svelte` 文件也可以通過 `+layout.js` 或 `+layout.server.js` 加載數據。

`src/routes/blog/[slug]/+layout.server.js`
```js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
	export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>>
}

// @filename: index.js
// ---cut---
import * as db from '$lib/server/database';

/** @type {import('./$types').LayoutServerLoad} */
export async function load() {
	return {
		posts: await db.getPostSummaries()
	};
}
```

`src/routes/blog/[slug]/+layout.svelte`
```svelte
<script>
	/** @type {{ data: import('./$types').LayoutData, children: Snippet }} */
	let { data, children } = $props();
</script>

<main>
	<!-- +page.svelte 在此處被 `@render` -->
	{@render children()}
</main>

<aside>
	<h2>More posts</h2>
	<ul>
		{#each data.posts as post}
			<li>
				<a href="/blog/{post.slug}">
					{post.title}
				</a>
			</li>
		{/each}
	</ul>
</aside>
```

佈局 `load` 函數返回的資料可供子 `+layout.svelte` 組件和 `+page.svelte` 組件以及它"所屬"的佈局都可用。

`src/routes/blog/[slug]/+page`
```svelte
<script>
	import { page } from '$app/state';

	/** @type {import('./$types').PageProps} */
	let { data } = $props();

	// 我們可以訪問 data.posts 因為它是從
	// 父佈局的 load 函數返回的
	let index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));
	let next = $derived(data.posts[index + 1]);
</script>

<h1>{data.post.title}</h1>
<div>{@html data.post.content}</div>

{#if next}
	<p>Next post: <a href="/blog/{next.slug}">{next.title}</a></p>
{/if}
```

> ❗ 如果多個 load 函數返回具有相同鍵的數據，最後一個會"勝出" —— 佈局 load 返回 { a: 1, b: 2 } 而頁面 load 返回 { b: 3, c: 4 } 的結果將是 { a: 1, b: 3, c: 4 }。

## page.data
`+page.svelte` 組件及其上面的每個 `+layout.svelte` 組件都可以訪問自己的數據以及其所有父組件的數據。
在某些情況下，我們可能需要相反的效果 - 父佈局可能需要訪問頁面數據或來自子佈局的數據。例如，根佈局可能想要訪問從 `+page.js` 或 `+page.server.js` 中的 `load` 函數返回的 `title` 屬性。這可以通過 `page.data` 實現:

`src/routes/+layout.svelte`
```svelte
<script>
	import { page } from '$app/state';
</script>

<svelte:head>
	<title>{page.data.title}</title>
</svelte:head>
```

`page.data` 的類型信息由 `App.PageData` 提供。

> ⚠️ `$app/state` 是在 SvelteKit 2.12 中添加的。如果您使用的是早期版本或使用 Svelte 4，請使用 `$app/stores` 代替。它提供了一個具有相同接口的 `page` store，您可以訂閲它，例如 `$page.data.title`。

## Universal vs server
目前有兩種類型的 load 函數:
- `+page.js` 和 `+layout.js` 文件導出的在服務端和瀏覽器上都運行的<b>Universal</b> `load` 函數
- `+page.server.js` 和 `+layout.server.js` 文件導出的只在服務端運行的<b>server</b> `load` 函數

### When does which load function run?
server `load` 函數總是在服務端上運行。

預設情況下，Universal `load` 函數在用户首次訪問頁面時在 SSR 期間在服務端上運行。然後它們會在hydration 中再次運行，複用來自 fetch 請求的任何響應。所有後續調用 Universal `load` 函數都發生在瀏覽器中。您可以通過頁面選項自定義該行為。如果您禁用了服務端渲染，您將獲得一個 SPA，Universal `load` 函數始終在客户端運行。

如果一個路由同時包含 Universal 和 server `load` 函數，server `load` 函數會先運行。

除非您預渲染頁面 - 在這種情況下，它會在構建時被調用，否則 `load` 函數會在運行時被調用。

### Input
Universal 和 server `load` 函數都可以訪問描述請求的屬性(`params`、`route` 和 `url`)以及各種函數(`fetch`、`setHeaders`、`parent`、`depends` 和 `untrack`)。這些在後面的章節中會描述。

server `load` 函數使用 `ServerLoadEvent` 調用，它從 `RequestEvent` 繼承 `clientAddress`、`cookies`、`locals`、`platform` 和 `request`。

Universal `load` 函數使用具有 `data` 屬性的 `LoadEvent` 調用。如果您在 `+page.js` 和 `+page.server.js`(或 `+layout.js` 和 `+layout.server.js`)中都有 `load` 函數，則 server `load` 函數的返回值是 Universal `load` 函數參數的 `data` 屬性。

### Output
Universal `load` 函數可以返回包含任何值的對象，包括自定義類和組件構造函數等內容。

server `load` 函數必須返回可以用 devalue 序列化的數據 - 任何可以用 JSON 表示的內容，以及像 `BigInt`、`Date`、`Map`、`Set` 和 `RegExp` 這樣的內容，或重複/循環引用 - 這樣它才能通過網絡傳輸。您的數據可以包含 `promises`，在這種情況下它將被流式傳輸到瀏覽器。

### When to use which
當您需要直接訪問數據庫或文件系統，或需要使用私有環境變量時，server `load` 函數很方便。

當您需要從外部 API fetch 數據且不需要私有憑據時，Universal load 函數很有用，因為 SvelteKit 可以直接從 API 獲取數據而無需通過服務端。當您需要返回無法序列化的內容(如 Svelte 組件構造函數)時，它們也很有用。

在極少數情況下，您可能需要同時使用兩者 - 例如，您可能需要返回一個使用服務端數據初始化的自定義類的實例。當同時使用兩者時，server `load` 的返回值不會直接傳遞給頁面，而是傳遞給 Universal `load` 函數(作為 `data` 屬性):

`src/routes/+page.server.js`
```js
/** @type {import('./$types').PageServerLoad} */
export async function load() {
	return {
		serverMessage: 'hello from server load function'
	};
}
```

`src/routes/+page.js`
```js
/** @type {import('./$types').PageLoad} */
export async function load({ data }) {
	return {
		serverMessage: data.serverMessage,
		universalMessage: 'hello from universal load function'
	};
}
```

## Using URL data

通常 `load` 函數以某種方式依賴於 `URL`。為此，`load` 函數提供了 `url`、`route` 和 `params`。

### url

`URL` 的一個實例，包含諸如 `origin`、`hostname`、`pathname` 和 `searchParams`(包含解析後的查詢字符串，作為 `URLSearchParams` 對象)等屬性。在 `load` 期間無法訪問 `url.hash`，因為它在服務端上不可用。

### route

包含當前路由目錄相對於 `src/routes` 的名稱:

`src/routes/a/[b]/[...c]/+page.js`
```js
/** @type {import('./$types').PageLoad} */
export function load({ route }) {
	console.log(route.id); 
  // log: '/a/[b]/[...c]'
}
```

### params

`params` 是從 `url.pathname` 和 `route.id` 派生的。
給定一個 route.id 為 /a/[b]/[...c] 且 url.pathname 為 /a/x/y/z 時，params 對象將如下所示:

```json 
{
	"b": "x",
	"c": "y/z"
}
```


## Making fetch requests
要從外部 API 或 `+server.js` 處理程序獲取數據，您可以使用提供的 `fetch` 函數，它的行為與原生 `fetch` web API完全相同，但有一些額外的功能:

- 它可以在服務端上發起帶憑據的請求，因為它繼承了頁面請求的 `cookie` 和 `authorization` 標頭。
```
🍪 用户的 cookies 和登入狀態會自動傳遞

用户請求頁面時帶著：
├── Cookie: session=abc123
└── Authorization: Bearer token

SvelteKit fetch 會自動帶上這些資訊！
```
- 它可以在服務端上發起相對請求(通常，當在服務端上下文中使用時，`fetch` 需要帶有源的 `URL`)。
```js
// ✅ 在伺服器端也能用相對路徑
const response = await fetch('/api/posts');  // 自動變成完整 URL

// ❌ 普通 fetch 在伺服器端需要完整 URL
const response = await fetch('https://mysite.com/api/posts');
```
- 內部請求(例如對 `+server.js` 路由的請求)在服務端上運行時直接轉到處理函數，無需 HTTP 調用的開銷。
```
效能優化：直接呼叫而不走網路

當你呼叫自己的 API：
fetch('/api/posts') 
      ↓
不會真的發 HTTP 請求！
      ↓
直接執行 +server.js 裡的函數
```
- 在服務端渲染期間，通過鈎入 `text`、`json` 和 `arrayBuffer` 方法來捕獲響應並將其內聯到渲染的 HTML 中 Response 對象。請注意，除非通過 `filterSerializedResponseHeaders` 顯式包含，否則標頭將不會被序列化。
```
防止重複請求

伺服器端：
├── fetch('/api/posts') → 取得資料
├── 把資料嵌入到 HTML 中
└── 傳送給瀏覽器

瀏覽器端：
├── 不需要重新 fetch
├── 直接從 HTML 讀取資料
└── 節省網路請求！
```
- 在 hydration 中，response 將從 HTML 中讀取，確保一致性並防止額外的網絡請求 - 如果在使用瀏覽器 `fetch` 而不是 `load` 的 `fetch` 時，在瀏覽器控制枱中收到警告，這就是原因。

`src/routes/items/[id]/+page.js`
```js
/** @type {import('./$types').PageLoad} */
export async function load({ fetch, params }) {
	const res = await fetch(`/api/items/${params.id}`);
	const item = await res.json();

	return { item };
}
```
```
用户訪問 /blog
      ↓
🖥️ 伺服器執行 load 函數
      ↓
📡 fetch('/api/posts') 
      ↓
🗄️ 取得部落格文章資料
      ↓
🎨 渲染成完整 HTML：
   <article>文章1</article>
   <article>文章2</article>
   <script>
     // 把資料嵌入這裡
     window.__sveltekit_data = { posts: [...] }
   </script>
      ↓
📤 傳送給瀏覽器
      ↓
🌐 瀏覽器收到已經有內容的頁面
      ↓
⚡ Hydration：JavaScript 從嵌入的資料恢復狀態
```

### Cookies
server `load` 函數可以獲取和設置 `cookies`。

`src/routes/+layout.server.js`
```js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
  export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }>
}

// @filename: index.js
// ---cut---
import * as db from '$lib/server/database';

/** @type {import('./$types').LayoutServerLoad} */
export async function load({ cookies }) {
  const sessionid = cookies.get('sessionid');

  return {
    user: await db.getUser(sessionid)
  };
}
```

只有當目標主機與 SvelteKit 應用程序相同或是其更具體的子域名時，Cookie 才會通過提供的 `fetch` 函數傳遞。

例如，如果 SvelteKit 正在為 my.domain.com 提供服務：
  - domain.com 將不會接收 cookies
  - my.domain.com 將會接收 cookies
  - api.domain.com 將不會接收 cookies
  - sub.my.domain.com 將會接收 cookies

當設置 `credentials: 'include'` 時，其他 cookies 將不會被傳遞，因為 SvelteKit 無法知道哪個 cookie 屬於哪個域（瀏覽器不會傳遞這些信息），所以轉發任何 cookie 都是不安全的。使用 handleFetch hook 鈎子來解決這個問題。

## Headers

Universal 和 server `load` 函數都可以訪問 `setHeaders` 函數，當在服務端上運行時，可以為響應設置頭部信息。（在瀏覽器中運行時，`setHeaders` 不會產生效果。）這在你想要緩存頁面時很有用，例如：

`src/routes/products/+page.js`
```js
/** @type {import('./$types').PageLoad} */
export async function load({ fetch, setHeaders }) {
	const url = `https://cms.example.com/products.json`;
	const response = await fetch(url);

	// Headers are only set during SSR, caching the page's HTML
	// for the same length of time as the underlying data.
	setHeaders({
		age: response.headers.get('age'),
		'cache-control': response.headers.get('cache-control')
	});

	return response.json();
}
```

多次設置相同的標頭（即使在不同的 `load` 函數中）是一個錯誤。使用 `setHeaders` 函數時，每個標頭只能設置一次。你不能使用 `setHeaders` 添加 `set-cookie` 標頭 — 應該使用 `cookies.set(name, value, options)` 代替。

```js
// ❌ 錯誤
setHeaders({ 'set-cookie': 'session=abc123' });

// ✅ 正確：使用 cookies API
export async function load({ cookies }) {
    cookies.set('session', 'abc123');
}
```

## Using parent data
有時候讓 `load` 函數訪問父級 `load` 函數中的數據是很有用的，這可以通過 `await parent()` 實現：

```
📁 src/routes/
├── +layout.js           → 爺爺 { a: 1 }
├── abc/
│   ├── +layout.js       → 爸爸 { b: 2 } (可以拿爺爺的 a)
│   └── +page.js         → 兒子 { c: 3 } (可以拿爺爸的 a, b)
```

`src/routes/+layout.js`
```js
/** @type {import('./$types').LayoutLoad} */
export function load() {
	return { a: 1 };
}
```

`src/routes/abc/+layout.js`
```js
/** @type {import('./$types').LayoutLoad} */
export async function load({ parent }) {
	const { a } = await parent();
	return { b: a + 1 };
}
```

`src/routes/abc/+page.js`
```js
/** @type {import('./$types').PageLoad} */
export async function load({ parent }) {
	const { a, b } = await parent();
	return { c: a + b };
}
```

`src/routes/abc/+page.svelte`
```svelte
<script>
  /** @type {{ data: import('./$types').PageData }} */
  let { data } = $props();
</script>

<!-- renders `1 + 2 = 3` -->
<p>{data.a} + {data.b} = {data.c}</p>
```

> ❗ 注意，`+page.js` 中的 `load` 函數接收來自兩個佈局 `load` 函數的合併數據，而不僅僅是直接父級的數據。

在 `+page.server.js` 和 `+layout.server.js` 內部，`parent` 從父級 `+layout.server.js` 文件返回數據。

在 `+page.js` 或 `+layout.js` 中，它將返回父級 `+layout.js` 文件中的數據。然而，缺失的 `+layout.js` 會被視為 `({ data }) => data` 函數，這意味着它也會返回未被 `+layout.js` 文件"遮蔽"的父級 `+layout.server.js` 文件中的數據。

使用 `await parent()` 時要注意避免瀑布流。例如，`getData(params)` 並不依賴於調用 `parent()` 的結果，所以我們應該先調用它以避免延遲渲染。

`+page.js`
```js
// @filename: ambient.d.ts
declare function getData(params: Record<string, string>): Promise<{ meta: any }>

// @filename: index.js
// ---cut---
/** @type {import('./$types').PageLoad} */
export async function load({ params, parent }) {
  ---const parentData = await parent();---
  const data = await getData(params);
  const parentData = await parent();

  return {
    ...data,
    meta: { ...parentData.meta, ...data.meta }
  };
}
```

## Errors


## Cookies
服务端 load 函数可以获取和设置cookies。
```js
/// file: src/routes/+layout.server.js
// @filename: ambient.d.ts
declare module '$lib/server/database' {
  export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }>
}

// @filename: index.js
// ---cut---
import * as db from '$lib/server/database';

/** @type {import('./$types').LayoutServerLoad} */
export async function load({ cookies }) {
  const sessionid = cookies.get('sessionid');

  return {
    user: await db.getUser(sessionid)
  };
}
```
只有当目标主机与 SvelteKit 应用程序相同或是其更具体的子域名时，Cookie 才会通过提供的 fetch 函数传递。

例如，如果 SvelteKit 正在为 my.domain.com 提供服务：

domain.com 将不会接收 cookies
my.domain.com 将会接收 cookies
api.domain.com 将不会接收 cookies
sub.my.domain.com 将会接收 cookies
当设置 credentials: 'include' 时，其他 cookies 将不会被传递，因为 SvelteKit 无法知道哪个 cookie 属于哪个域（浏览器不会传递这些信息），所以转发任何 cookie 都是不安全的。使用 handleFetch hook 钩子来解决这个问题。